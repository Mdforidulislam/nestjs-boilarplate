generator client {
  provider = "prisma-client-js"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(uuid())
  username         String?
  email            String         @unique
  description      String?
  bankId           String?
  contactNo        String         @unique
  password         String
  lang             Lang           @default(ENG)
  role             Role           @default(CUSTOMER)
  avatar           String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  admin            Admin?
  chatsReceived    Chat[]         @relation("ReceiverRelation")
  chatsSent        Chat[]         @relation("SenderRelation")
  customer         Customer?
  notifications    Notification[]
  roomParticipants RoomUser[]
  createdRooms     Room[]         @relation("CreatorRelation")
  roomsReceived    Room[]         @relation("ReceiverRelation")
  roomsSent        Room[]         @relation("SenderRelation")
  verifications    Verification[]

  @@map("users")
}

model Verification {
  id        String   @id @default(uuid())
  email     String
  userId    String
  otp       Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])  

  @@map("verifications")
}

model Admin {
  id        String   @id @default(uuid())
  userId    String   @unique
  fullName  String
  location  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@map("admins")
}

model Customer {
  id                  String              @id @default(uuid())
  userId              String              @unique
  fullName            String?
  location            String?
  address             String?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  user                User                @relation(fields: [userId], references: [id])

  payments            Payment[]
  @@map("customers")
}



model Subscription {
  id                   String             @id @default(uuid())
  subscriptionPlanId   String            
  ownerId               String?
  subscriptionStatus   SubscriptionStatus @default(ACTIVE)
  stripeSubscriptionId String?
  stripeCustomerId     String?
  expiresAt            DateTime
  createdAt            DateTime           @default(now())
  cancelRequest        Boolean            @default(false)
  subscriptionPlan     SubscriptionPlan   @relation(fields: [subscriptionPlanId], references: [id])
  payments             Payment[]   

  @@map("subscriptions")
}

model SubscriptionPlan {
  id            String                 @id @default(uuid())
  plan          SubscribePlan          @default(MONTH)
  status        SubscriptionPlanStatus @default(ACTIVE)
  name          String
  planType      PlanType
  description   String
  featuresList  String[]
  trialPeriod   Boolean                @default(false)
  price         Float                  @default(0)
  stripePriceId String                 @default("")
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt
  subscription  Subscription[]

  @@map("subscription_plans")
}

model Payment {
  id                 String        @id @default(uuid())
  customerId         String?
  brokerFirmId       String?
  amount             Float
  currency           String
  paymentDate        DateTime
  paymentStatus      PaymentStatus
  subscriptionId     String?
  subscriptionPlanId String?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  customer           Customer?      @relation(fields: [customerId], references: [id])
  subscription       Subscription? @relation(fields: [subscriptionId], references: [id])

  @@map("payments")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  title     String
  body      String
  data      String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])

  @@map("notifications")
}

model RoomUser {
  id        String   @id @default(uuid())
  roomId    String
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  room      Room     @relation(fields: [roomId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, roomId])
  @@map("room_users")
}

model Room {
  id           String     @id @default(uuid())
  type         RoomType   @default(GROUP)
  name         String?
  description  String?
  img          String?
  senderId     String?
  receiverId   String?
  creatorId    String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  userId       String?
  chat         Chat[]
  participants RoomUser[]
  creator      User       @relation("CreatorRelation", fields: [creatorId], references: [id])
  receiver     User?      @relation("ReceiverRelation", fields: [receiverId], references: [id])
  sender       User?      @relation("SenderRelation", fields: [senderId], references: [id])

  @@map("rooms")
}

model Chat {
  id         String   @id @default(uuid())
  senderId   String
  receiverId String?
  roomId     String
  message    String
  images     String[]
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  receiver   User?    @relation("ReceiverRelation", fields: [receiverId], references: [id])
  room       Room     @relation(fields: [roomId], references: [id])
  sender     User     @relation("SenderRelation", fields: [senderId], references: [id])

  @@map("chats")
}

enum PlanType {
  SUBSRIPTION_CUSTOMER
  SUBSCRIPTION_BROKER_FIRM
}

enum Role {
  SUPER_ADMIN
  ADMIN
  CUSTOMER
}


enum Lang {
  ENG
  ARB
}

enum RoomType {
  PRIVATE
  GROUP
}


enum SubscriptionPlanStatus {
  ACTIVE
  INACTIVE
}

enum SubscriptionStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELLED
  PAST_DUE
}

enum PaymentMethod {
  STRIPE
  PAYPAL
}

enum SubscribePlan {
  MONTH
  THREE_MONTH
  ONE_TIME
}

enum PaymentStatus {
  REQUIRES_PAYMENT_METHOD
  REQUIRES_CONFIRMATION
  REQUIRES_ACTION
  PROCESSING
  REQUIRES_CAPTURE
  CANCELED
  SUCCEEDED
  REFUNDED
  PARTIALLY_REFUNDED
  FAILED
}
